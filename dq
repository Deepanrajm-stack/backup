# Databricks notebook source
# MAGIC %pip install openpyxl

# COMMAND ----------

# DBTITLE 1,Import Libraries
from pyspark.sql.functions import col, when, count, lit, to_date
from pyspark.sql import DataFrame 
from datetime import date
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.application import MIMEApplication
import pandas as pd
import tempfile
import os
from openpyxl import Workbook

# COMMAND ----------

# MAGIC %run /Workspace/Users/dmuniraj@amgen.com/routingiq_clone/config/routingiq_config.py

# COMMAND ----------


df_rep = spark.table(dev_rep_routing_alignment_table)
max_date_rep = df_rep.agg({"processing_date": "max"}).collect()[0][0]
df_rep = df_rep.filter(col("processing_date") == lit(max_date_rep))
 
# -----------------------------------------------

df_json = spark.table(routingiq_json_input_data_table) 
max_date_json = df_json.agg({"processing_date": "max"}).collect()[0][0]
df_json = df_json.filter(col("processing_date") == lit(max_date_json))

# COMMAND ----------

# DBTITLE 1,Dup check
dq1_df = df.groupBy("Account__c") \
    .agg(count("*").alias("record_count")) \
    .filter((col("Account__c").isNotNull()) & (col("record_count") > 1)) \
    .withColumn("DQ_Rule", when(col("record_count") > 1, "Duplicate Account__c"))

# COMMAND ----------

#If Customer ID is present, then Customer_Latitude__c and Customer_Longitude__c must not be null
dq2_df = df.filter(
    (col("Account__c").isNotNull()) &
    ((col("Customer_Latitude__c").isNull()) | (col("Customer_Longitude__c").isNull()))
).withColumn("DQ_Rule", when(col("Customer_Latitude__c").isNull(), "Latitude Null when Account__c present")
             .otherwise("Longitude Null when Account__c present"))


# COMMAND ----------

#If Customer ID is present and Type is Walkin/Appointment/Call, then distance must be null and Latitude/Longitude must not be null
valid_types = ["Walkin", "Appointment", "Call"]

dq3_df = df.filter(
    (col("Account__c").isNotNull()) &
    (col("Type__c").isin(valid_types)) &
    (
        col("Distance__c").isNotNull() |
        col("Customer_Latitude__c").isNull() |
        col("Customer_Longitude__c").isNull()
    )
).withColumn(
    "DQ_Rule", 
    when(col("Distance__c").isNotNull(), "Distance not null for Walkin/Appointment/Call")
    .otherwise("Lat/Long null for Walkin/Appointment/Call")
)

# COMMAND ----------

#If Account__c is null and Type_C is 'Travel', then distance must not be null
dq4_df = df.filter(
    (col("Account__c").isNull()) &
    (col("Type__c") == "Travel") &
    (col("Distance__c").isNull())
).withColumn("DQ_Rule", when(col("Distance__c").isNull(), "Distance null when Account__c is null and Type__c is Travel"))

# COMMAND ----------

# When Type__c is 'Wait', following fields must be null
dq5_df = df.filter(
    (col("Type__c") == "Wait") & (
        col("CustomerValuationSegement__c").isNotNull() |
        col("Customer_ID__c").isNotNull() |
        col("Customer_Latitude__c").isNotNull() |
        col("Customer_Longitude__c").isNotNull() |
        col("Customer_Order__c").isNotNull() |
        col("Customer_Priority__c").isNotNull() |
        col("Distance__c").isNotNull() |
        col("Route_Points_Location__c").isNotNull()
    )
).withColumn(
    "DQ_Rule", 
    when(col("Type__c") == "Wait", "Fields must be null when Type__c is 'Wait'")
)

# COMMAND ----------

combined_failures_df = dq1_df.selectExpr("*") \
    .unionByName(dq2_df.selectExpr("*"), allowMissingColumns=True) \
    .unionByName(dq3_df.selectExpr("*"), allowMissingColumns=True) \
    .unionByName(dq4_df.selectExpr("*"), allowMissingColumns=True) \
    .unionByName(dq5_df.selectExpr("*"), allowMissingColumns=True)

# COMMAND ----------

# DBTITLE 1,Appointment_date_validation
# Extract date from timestamp
df_json_clean = df_json.withColumn("appointment_date", to_date("appointment_date_time"))

# Perform LEFT JOIN on customer_id and appointment_date
dq_mismatch_df = df_json_clean.alias("json").join(
    df_rep.alias("rep"),
    (col("json.customer_id") == col("rep.Customer_ID__c")) &
    (col("json.appointment_date") == col("rep.Date__c")),
    how="left"
)
#  DQ_Rule and filter where records are truly mismatched, excluding both-null
dq_mismatch_df = dq_mismatch_df.filter(
    ~(
        col("json.appointment_date").isNull() & col("rep.Date__c").isNull()
    ) &
    (
        col("rep.Customer_ID__c").isNull() | col("rep.Date__c").isNull()
    )
).withColumn("DQ_Rule", lit("DQ_Appointment_Missing_in_Rep"))

# COMMAND ----------

# DBTITLE 1,Email notification
# Count number of failed records
failure_count = combined_failures_df.count()

if failure_count > 0:
    # summary and sample records
    dq_check_summary_df = combined_failures_df.groupBy("DQ_Rule").count().toPandas()
    dq_check_summary_html = dq_check_summary_df.to_html(index=False, escape=False)

    sample_failures_pdf = combined_failures_df.limit(10).toPandas()
    sample_failures_html = sample_failures_pdf.to_html(index=False, escape=False)

    # Create Excel attachment with sample records
    tmp_excel_path = os.path.join(tempfile.gettempdir(), "DQ_Failures_Rep_Sample.xlsx")
    with pd.ExcelWriter(tmp_excel_path, engine='openpyxl') as writer:
        sample_failures_pdf.to_excel(writer, sheet_name="SampleFailures", index=False)

    # Email body
    email_body = f"""
    <h3>Data Quality Check - Summary</h3>
    <p><strong>Total Failed Records:</strong> {failure_count}</p>

    <h4>DQ Check Type:</h4>
    {dq_check_summary_html}

    <h4>Sample Failed Records:</h4>
    {sample_failures_html}
    <p>Excel file with sample records attached.</p>
    """

    # Email addresses
    from_email = "dmuniraj@amgen.com"
    to_email = "dmuniraj@amgen.com"
    all_recipients = [to_email]

    msg = MIMEMultipart()
    msg['From'] = from_email
    msg['To'] = ", ".join(all_recipients)
    msg['Subject'] = "Post Data Quality Check - Summary"
    msg.attach(MIMEText(email_body, 'html'))

    # Attach Excel file
    with open(tmp_excel_path, "rb") as f:
        part = MIMEApplication(f.read(), _subtype='octet-stream')
        part.add_header("Content-Disposition", "attachment", filename="DQ_Failures_Sample.xlsx")
        msg.attach(part)

    try:
        with smtplib.SMTP('mailhost-i.amgen.com') as server:
            server.sendmail(from_email, all_recipients, msg.as_string())
        print("DQ issues found. Notification sent with Excel attachment.")
    except Exception as e:
        print(f"Failed to send email: {e}")
else:
    print("No DQ failures found.")
